<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Tools - Client-Side PDF Processing</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- PDF-Lib: The core library for PDF manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <!-- PDF.js: For rendering PDF previews -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // Configure the PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>

    <!-- Tesseract.js for OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js'></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Custom styles to complement Tailwind and achieve a Material look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .tool-card {
            transition: all 0.2s ease-in-out;
        }
        .tool-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        /* Custom file input */
        input[type="file"]::file-selector-button {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #4338ca; /* indigo-700 */
        }
        /* Spinner animation */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }
        /* Toast notification animation */
        .toast {
            animation: fadeInOut 4s ease-in-out;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateY(20px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Main Container -->
    <div class="container mx-auto px-4 py-8 md:py-12">

        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-indigo-600 mb-2">Gemini PDF Tools</h1>
            <p class="text-lg text-slate-500">Fast, private, and secure PDF tools that run entirely in your browser.</p>
            <p class="text-sm text-slate-400 mt-2">Your files never leave your computer.</p>
        </header>

        <!-- Tool Grid -->
        <main id="tool-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 md:gap-6">
            <!-- Tool cards will be dynamically inserted here -->
        </main>

        <!-- Workspace for active tool -->
        <section id="workspace" class="hidden">
            <!-- Workspace content will be dynamically inserted here -->
        </section>

    </div>

    <!-- Global Spinner -->
    <div id="spinner-overlay" class="hidden fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50">
        <div class="flex flex-col items-center">
            <div class="spinner border-4 border-t-4 border-slate-200 border-t-indigo-600 rounded-full w-12 h-12"></div>
            <p id="spinner-message" class="mt-4 text-slate-600"></p>
        </div>
    </div>

    <!-- Global Toast Notification -->
    <div id="toast-notification" class="hidden fixed bottom-5 right-5 p-4 rounded-lg shadow-xl text-white">
        <p id="toast-message"></p>
    </div>

    <script>
        // Immediately-invoked function expression (IIFE) to encapsulate the app logic
        (async () => {
            // Destructure PDFLib functions for easy access
            const { PDFDocument, rgb, StandardFonts } = PDFLib;

            // DOM Element References
            const toolGrid = document.getElementById('tool-grid');
            const workspace = document.getElementById('workspace');
            const spinner = document.getElementById('spinner-overlay');
            const spinnerMessage = document.getElementById('spinner-message');
            const toast = document.getElementById('toast-notification');
            const toastMessage = document.getElementById('toast-message');

            // --- STATE ---
            let selectedFiles = [];

            // --- AVAILABLE TOOLS ---
            const tools = [
                {
                    id: 'merge',
                    title: 'Merge PDF',
                    icon: 'copy-plus',
                    description: 'Combine multiple PDFs into one single document.',
                    multipleFiles: true,
                    render: renderMergeUI,
                    process: processMerge,
                },
                {
                    id: 'split',
                    title: 'Split PDF',
                    icon: 'scissors',
                    description: 'Extract pages from a PDF by providing page ranges.',
                    multipleFiles: false,
                    render: renderSplitUI,
                    process: processSplit,
                },
                 {
                    id: 'ocr',
                    title: 'Extract Text (OCR)',
                    icon: 'file-text',
                    description: 'Recognize and extract text from a scanned PDF.',
                    multipleFiles: false,
                    render: renderOcrUI,
                    process: processOcr,
                },
                {
                    id: 'rotate',
                    title: 'Rotate PDF',
                    icon: 'rotate-cw',
                    description: 'Rotate all or specific pages of your PDF.',
                    multipleFiles: false,
                    render: renderRotateUI,
                    process: processRotate,
                },
                {
                    id: 'add-numbers',
                    title: 'Page Numbers',
                    icon: 'hash',
                    description: 'Add page numbers to your PDF document.',
                    multipleFiles: false,
                    render: renderPageNumbersUI,
                    process: processPageNumbers,
                },
                {
                    id: 'image-to-pdf',
                    title: 'Image to PDF',
                    icon: 'image',
                    description: 'Convert JPG or PNG images into a PDF file.',
                    multipleFiles: true,
                    render: renderImageToPdfUI,
                    process: processImageToPdf,
                    accept: 'image/jpeg, image/png'
                },
                {
                    id: 'protect',
                    title: 'Protect PDF',
                    icon: 'lock',
                    description: 'Add a password and encrypt your PDF file.',
                    multipleFiles: false,
                    render: renderProtectUI,
                    process: processProtect,
                }
            ];

            // --- CORE UI FUNCTIONS ---

            // Renders the main grid of tool cards
            function renderToolGrid() {
                toolGrid.innerHTML = '';
                tools.forEach(tool => {
                    const card = document.createElement('div');
                    card.className = 'tool-card bg-white p-4 rounded-xl shadow-md cursor-pointer flex flex-col items-center text-center';
                    card.innerHTML = `
                        <i data-lucide="${tool.icon}" class="w-10 h-10 text-indigo-500 mb-3"></i>
                        <h3 class="font-semibold text-slate-800">${tool.title}</h3>
                    `;
                    card.addEventListener('click', () => showWorkspace(tool));
                    toolGrid.appendChild(card);
                });
                lucide.createIcons();
            }

            // Shows the workspace for a selected tool
            function showWorkspace(tool) {
                toolGrid.classList.add('hidden');
                workspace.classList.remove('hidden');
                workspace.innerHTML = `
                    <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
                        <div class="flex items-center justify-between mb-6">
                            <button id="back-button" class="flex items-center gap-2 text-slate-500 hover:text-indigo-600 transition">
                                <i data-lucide="arrow-left" class="w-5 h-5"></i>
                                Back to Tools
                            </button>
                            <h2 class="text-2xl font-bold text-indigo-600 flex items-center gap-3">
                                <i data-lucide="${tool.icon}" class="w-7 h-7"></i>
                                ${tool.title}
                            </h2>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                            <div id="preview-container" class="lg:col-span-3 bg-slate-100 p-2 rounded-lg h-[70vh] overflow-auto border flex items-center justify-center">
                                <p class="text-slate-400 text-center p-4">Select a file to see a preview.</p>
                            </div>
                            <div id="tool-options-container" class="lg:col-span-2 flex flex-col">
                                <p class="text-slate-500 mb-4">${tool.description}</p>
                                <div id="tool-specific-options" class="flex-grow flex flex-col">
                                    <!-- Tool-specific controls will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('back-button').addEventListener('click', hideWorkspace);
                
                const toolOptionsContainer = document.getElementById('tool-options-container');
                const toolSpecificOptions = document.getElementById('tool-specific-options');

                // Render the file input as the primary action
                createFileInput(toolOptionsContainer, tool);
                
                // Render the unique options for the selected tool
                tool.render(toolSpecificOptions, tool);

                // Render the final process button, unless it's a special case like OCR
                if (tool.id !== 'ocr') {
                    createProcessButton(toolOptionsContainer, tool, 'Process');
                }

                lucide.createIcons();
            }

            // Hides the workspace and shows the tool grid
            function hideWorkspace() {
                workspace.innerHTML = '';
                workspace.classList.add('hidden');
                toolGrid.classList.remove('hidden');
            }

            // Generic UI for file input
            function createFileInput(parent, tool) {
                 const fileInputHTML = `
                    <div class="mb-4">
                        <label for="file-input" class="block mb-2 font-medium text-slate-700">Select File(s)</label>
                        <input type="file" id="file-input" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold" 
                            ${tool.multipleFiles ? 'multiple' : ''} 
                            accept="${tool.accept || '.pdf'}">
                    </div>
                `;
                // Prepend it to the container
                parent.insertAdjacentHTML('afterbegin', fileInputHTML);

                document.getElementById('file-input').addEventListener('change', (e) => {
                    selectedFiles = Array.from(e.target.files);
                    if (selectedFiles.length === 0) {
                        clearPreview();
                        return;
                    }

                    // Render the appropriate preview based on the tool
                    if (tool.id === 'image-to-pdf') {
                        renderImagePreview(selectedFiles);
                    } else if (tool.id === 'merge') {
                        renderMergePreview(selectedFiles);
                    } else if (selectedFiles[0].type === 'application/pdf') {
                        renderPdfPreview(selectedFiles[0]);
                    } else {
                        clearPreview('Invalid file type selected.');
                    }
                });
            }

            // Generic UI for the process button
            function createProcessButton(parent, tool, buttonText = 'Process') {
                const buttonHTML = `
                    <div class="mt-auto border-t pt-6 text-right">
                        <button id="process-button" class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-all shadow-sm flex items-center gap-2 ml-auto">
                            <i data-lucide="${tool.id === 'ocr' ? 'scan-text' : 'settings-2'}" class="w-5 h-5"></i>
                            ${buttonText}
                        </button>
                    </div>
                `;
                parent.insertAdjacentHTML('beforeend', buttonHTML);

                document.getElementById('process-button').addEventListener('click', async () => {
                     if (selectedFiles.length === 0) {
                        showToast('Please select one or more files.', 'error');
                        return;
                    }
                    showSpinner(true);
                    try {
                        await tool.process(tool.id);
                    } catch (error) {
                        console.error('An error occurred:', error);
                        showToast(error.message || 'An unexpected error occurred.', 'error');
                    } finally {
                        showSpinner(false);
                    }
                });
                lucide.createIcons();
            }
            
            // --- UI RENDERERS FOR EACH TOOL ---

            function renderMergeUI(parent, tool) {
                // No specific options needed for merge besides the file input.
            }

            function renderSplitUI(parent, tool) {
                parent.innerHTML += `
                    <div class="mt-4">
                        <label for="split-ranges" class="block mb-2 font-medium text-slate-700">Page Ranges</label>
                        <input type="text" id="split-ranges" placeholder="e.g., 1-3, 5, 8-10" class="w-full p-2 border border-slate-300 rounded-md">
                    </div>
                `;
            }

            function renderRotateUI(parent, tool) {
                parent.innerHTML += `
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                        <div>
                            <label for="rotate-degrees" class="block mb-2 font-medium text-slate-700">Rotation Angle</label>
                            <select id="rotate-degrees" class="w-full p-2 border border-slate-300 rounded-md">
                                <option value="90">90째 Clockwise</option>
                                <option value="180">180째</option>
                                <option value="270">270째 Clockwise (-90째)</option>
                            </select>
                        </div>
                        <div>
                           <label for="rotate-pages" class="block mb-2 font-medium text-slate-700">Pages to Rotate</label>
                           <input type="text" id="rotate-pages" placeholder="e.g., 1-3, 5 (blank for all)" class="w-full p-2 border border-slate-300 rounded-md">
                        </div>
                    </div>
                `;
            }
            
            function renderPageNumbersUI(parent, tool) {
                parent.innerHTML += `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                         <div>
                            <label for="page-position" class="block mb-2 font-medium text-slate-700">Position</label>
                            <select id="page-position" class="w-full p-2 border border-slate-300 rounded-md">
                                <option value="bottom-center">Bottom Center</option>
                                <option value="bottom-left">Bottom Left</option>
                                <option value="bottom-right">Bottom Right</option>
                                <option value="top-center">Top Center</option>
                                <option value="top-left">Top Left</option>
                                <option value="top-right">Top Right</option>
                            </select>
                        </div>
                        <div>
                           <label for="font-size" class="block mb-2 font-medium text-slate-700">Font Size</label>
                           <input type="number" id="font-size" value="12" class="w-full p-2 border border-slate-300 rounded-md">
                        </div>
                    </div>
                `;
            }

            function renderImageToPdfUI(parent, tool) {
                // No specific options needed besides file input.
            }
            
            function renderProtectUI(parent, tool) {
                parent.innerHTML += `
                    <div class="mt-4">
                        <label for="password" class="block mb-2 font-medium text-slate-700">Password</label>
                        <input type="password" id="password" placeholder="Enter a strong password" class="w-full p-2 border border-slate-300 rounded-md">
                    </div>
                `;
            }

            function renderOcrUI(parent, tool) {
                parent.innerHTML = `
                    <div class="mt-4 bg-slate-50 rounded-lg border h-full flex flex-col">
                        <div class="p-3 border-b flex justify-between items-center">
                            <h3 class="font-semibold text-slate-700">Extracted Text</h3>
                            <div class="flex items-center space-x-2">
                                <button id="copy-btn" class="p-1.5 bg-slate-200 hover:bg-slate-300 text-slate-600 rounded-md transition disabled:opacity-50" title="Copy Text" disabled>
                                    <i data-lucide="copy" class="w-4 h-4"></i>
                                </button>
                                <button id="save-btn" class="p-1.5 bg-slate-200 hover:bg-slate-300 text-slate-600 rounded-md transition disabled:opacity-50" title="Save as .txt" disabled>
                                    <i data-lucide="save" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <pre id="ocr-output" class="whitespace-pre-wrap text-sm text-slate-800 bg-white p-3 flex-grow overflow-y-auto"></pre>
                    </div>
                `;
                createProcessButton(parent.parentElement, tool, 'Extract Text');
                
                document.getElementById('copy-btn').addEventListener('click', () => {
                    const output = document.getElementById('ocr-output');
                    if (output.textContent) {
                         const textArea = document.createElement("textarea");
                         textArea.value = output.textContent;
                         textArea.style.position = "fixed";
                         document.body.appendChild(textArea);
                         textArea.focus();
                         textArea.select();
                         try {
                             document.execCommand('copy');
                             showToast('Text copied to clipboard!', 'success');
                         } catch (err) {
                             showToast('Failed to copy text.', 'error');
                         }
                         document.body.removeChild(textArea);
                    }
                });

                document.getElementById('save-btn').addEventListener('click', () => {
                    const output = document.getElementById('ocr-output');
                    if (output.textContent && selectedFiles.length > 0) {
                        const originalFilename = selectedFiles[0].name.replace(/\.[^/.]+$/, "");
                        download(output.textContent, `${originalFilename}-extracted.txt`, 'text/plain');
                    }
                });
            }


            // --- PROCESSING LOGIC FOR EACH TOOL ---

            async function processMerge(toolId) {
                const mergedPdf = await PDFDocument.create();
                for (const file of selectedFiles) {
                    const pdfBytes = await file.arrayBuffer();
                    const pdfDoc = await PDFDocument.load(pdfBytes);
                    const copiedPages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
                    copiedPages.forEach(page => mergedPdf.addPage(page));
                }
                const pdfBytes = await mergedPdf.save();
                download(pdfBytes, 'merged.pdf', 'application/pdf');
                showToast('PDFs merged successfully!', 'success');
            }

            async function processSplit(toolId) {
                const ranges = document.getElementById('split-ranges').value;
                if (!ranges) throw new Error('Please specify page ranges.');
                
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const pageCount = pdfDoc.getPageCount();

                const pageIndices = parsePageRanges(ranges, pageCount);
                if(pageIndices.length === 0) throw new Error('Invalid or empty page ranges provided.');

                const newPdf = await PDFDocument.create();
                const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                copiedPages.forEach(page => newPdf.addPage(page));

                const newPdfBytes = await newPdf.save();
                download(newPdfBytes, `split-${file.name}`, 'application/pdf');
                showToast('PDF split successfully!', 'success');
            }
            
            async function processRotate(toolId) {
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                
                const degrees = parseInt(document.getElementById('rotate-degrees').value);
                const pageRanges = document.getElementById('rotate-pages').value;
                
                const pageCount = pdfDoc.getPageCount();
                const indicesToRotate = pageRanges ? parsePageRanges(pageRanges, pageCount) : pdfDoc.getPageIndices();

                indicesToRotate.forEach(index => {
                    const page = pdfDoc.getPage(index);
                    const currentRotation = page.getRotation().angle;
                    page.setRotation({ angle: (currentRotation + degrees) % 360 });
                });

                const newPdfBytes = await pdfDoc.save();
                download(newPdfBytes, `rotated-${file.name}`, 'application/pdf');
                showToast('PDF rotated successfully!', 'success');
            }
            
            async function processPageNumbers(toolId) {
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const pages = pdfDoc.getPages();
                
                const position = document.getElementById('page-position').value;
                const fontSize = parseInt(document.getElementById('font-size').value);
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

                for (let i = 0; i < pages.length; i++) {
                    const page = pages[i];
                    const { width, height } = page.getSize();
                    const pageNum = i + 1;
                    
                    let x, y;
                    const margin = 30;

                    switch(position) {
                        case 'bottom-left': x = margin; y = margin; break;
                        case 'bottom-right': x = width - margin - (fontSize * 0.5 * String(pageNum).length) ; y = margin; break;
                        case 'top-center': x = width / 2 - (fontSize * 0.25 * String(pageNum).length); y = height - margin; break;
                        case 'top-left': x = margin; y = height - margin; break;
                        case 'top-right': x = width - margin - (fontSize * 0.5 * String(pageNum).length); y = height - margin; break;
                        default: // bottom-center
                            x = width / 2 - (fontSize * 0.25 * String(pageNum).length);
                            y = margin;
                            break;
                    }
                    
                    page.drawText(String(pageNum), { x, y, size: fontSize, font, color: rgb(0, 0, 0) });
                }

                const newPdfBytes = await pdfDoc.save();
                download(newPdfBytes, `numbered-${file.name}`, 'application/pdf');
                showToast('Page numbers added successfully!', 'success');
            }

            async function processImageToPdf(toolId) {
                const pdfDoc = await PDFDocument.create();
                for (const file of selectedFiles) {
                    const imgBytes = await file.arrayBuffer();
                    const image = file.type === 'image/png' 
                        ? await pdfDoc.embedPng(imgBytes) 
                        : await pdfDoc.embedJpg(imgBytes);
                    
                    const page = pdfDoc.addPage();
                    const { width, height } = image.scale(1);
                    page.setSize(width, height);
                    page.drawImage(image, { x: 0, y: 0, width, height });
                }

                const pdfBytes = await pdfDoc.save();
                download(pdfBytes, 'images.pdf', 'application/pdf');
                showToast('Images converted to PDF!', 'success');
            }
            
            async function processProtect(toolId) {
                const password = document.getElementById('password').value;
                if (!password) throw new Error('Password cannot be empty.');

                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                
                const newPdfBytes = await pdfDoc.save({
                    useObjectStreams: false,
                    permissions: {
                        printing: 'high',
                        modifying: false,
                        copying: false,
                        annotating: false,
                        fillingForms: false,
                        contentAccessibility: false,
                        documentAssembly: false,
                    },
                    userPassword: password,
                });

                download(newPdfBytes, `protected-${file.name}`, 'application/pdf');
                showToast('PDF protected successfully!', 'success');
            }
            
            async function processOcr(toolId) {
                const file = selectedFiles[0];
                const output = document.getElementById('ocr-output');
                const copyBtn = document.getElementById('copy-btn');
                const saveBtn = document.getElementById('save-btn');
                
                output.textContent = '';
                copyBtn.disabled = true;
                saveBtn.disabled = true;

                let fullText = '';

                const fileReader = new FileReader();
                
                fileReader.onload = async (event) => {
                    const typedarray = new Uint8Array(event.target.result);
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;
                    
                    showSpinner(true, `Processing ${pdf.numPages} pages...`);

                    for (let i = 1; i <= pdf.numPages; i++) {
                        showSpinner(true, `Reading page ${i} of ${pdf.numPages}...`);
                        
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale: 2.0 });
                        
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        
                        showSpinner(true, `Extracting text from page ${i}...`);
                        
                        const { data: { text } } = await Tesseract.recognize(canvas, 'eng');
                        
                        fullText += text + `\n\n--- Page ${i} ---\n\n`;
                        output.textContent = fullText;
                        output.scrollTop = output.scrollHeight; // Auto-scroll
                    }
                    
                    showSpinner(false);
                    showToast('Text extraction complete!', 'success');
                    copyBtn.disabled = false;
                    saveBtn.disabled = false;
                };

                fileReader.readAsArrayBuffer(file);
            }


            // --- PREVIEW RENDERER FUNCTIONS ---

            function clearPreview(message = 'Select a file to see a preview.') {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = `<p class="text-slate-400 text-center p-4">${message}</p>`;
            }

            async function renderPdfPreview(file) {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = '<div class="spinner border-4 border-t-4 border-slate-200 border-t-indigo-600 rounded-full w-12 h-12"></div>';
                
                try {
                    const fileReader = new FileReader();
                    fileReader.onload = async function() {
                        const typedarray = new Uint8Array(this.result);
                        const pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                        
                        previewContainer.innerHTML = ''; // Clear spinner
                        
                        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                            const page = await pdfDoc.getPage(pageNum);
                            const viewport = page.getViewport({ scale: 1.5 });
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            canvas.className = 'mb-4 shadow-md';
                            
                            previewContainer.appendChild(canvas);
                            
                            const renderContext = {
                                canvasContext: context,
                                viewport: viewport
                            };
                            await page.render(renderContext).promise;
                        }
                    };
                    fileReader.readAsArrayBuffer(file);
                } catch (error) {
                    console.error("Error rendering PDF preview:", error);
                    clearPreview('Could not display a preview for this PDF.');
                }
            }
            
            function renderImagePreview(files) {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = '';
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-2 gap-2 p-2';
                files.forEach(file => {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.className = 'w-full h-auto object-cover rounded-md';
                    img.onload = () => URL.revokeObjectURL(img.src);
                    grid.appendChild(img);
                });
                previewContainer.appendChild(grid);
            }

            function renderMergePreview(files) {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = `
                    <div class="w-full p-4 text-left">
                        <h4 class="font-semibold text-slate-700 mb-2">Files to Merge:</h4>
                        <ul class="list-disc list-inside text-slate-600 text-sm space-y-1">
                            ${files.map(f => `<li>${f.name}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // --- HELPER FUNCTIONS ---

            // Toggles the visibility of the spinner
            function showSpinner(visible, message = '') {
                spinnerMessage.textContent = message;
                spinner.classList.toggle('hidden', !visible);
            }

            // Displays a toast notification
            function showToast(message, type = 'success') {
                toastMessage.textContent = message;
                toast.className = `fixed bottom-5 right-5 p-4 rounded-lg shadow-xl text-white toast ${
                    type === 'success' ? 'bg-green-500' : 'bg-red-500'
                }`;
                toast.classList.remove('hidden');
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 4000);
            }

            // Triggers a file download in the browser
            function download(bytes, filename, mimeType) {
                const blob = new Blob([bytes], { type: mimeType });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }

            // Parses page range strings (e.g., "1-3, 5, 8-10") into an array of zero-based indices
            function parsePageRanges(ranges, pageCount) {
                const indices = new Set();
                const parts = ranges.split(',').map(s => s.trim());
                for (const part of parts) {
                    if (part.includes('-')) {
                        const [start, end] = part.split('-').map(Number);
                        for (let i = start; i <= end; i++) {
                            if (i > 0 && i <= pageCount) indices.add(i - 1);
                        }
                    } else {
                        const pageNum = Number(part);
                        if (pageNum > 0 && pageNum <= pageCount) indices.add(pageNum - 1);
                    }
                }
                return Array.from(indices).sort((a,b) => a - b);
            }


            // --- INITIALIZATION ---
            document.addEventListener('DOMContentLoaded', () => {
                renderToolGrid();
            });

        })();
    </script>
</body>
</html>

