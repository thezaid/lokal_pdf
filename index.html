<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Tools - Client-Side PDF Processing</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- PDF-Lib: The core library for PDF manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <!-- PDF.js: For rendering PDF previews -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
    <script>
        // Configure the PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>

    <!-- Tesseract.js for OCR is now loaded on-demand by the worker, so it's removed from here -->

    <!-- JSZip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Custom styles to complement Tailwind and achieve a Material look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .tool-card {
            transition: all 0.2s ease-in-out;
        }
        .tool-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        /* Custom file input */
        input[type="file"]::file-selector-button {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #4338ca; /* indigo-700 */
        }
        /* Spinner animation */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }
        /* Toast notification animation */
        .toast {
            animation: fadeInOut 4s ease-in-out;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateY(20px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }
        /* Drag and drop styling */
        .drop-zone-active {
            border-color: #4f46e5; /* indigo-600 */
            background-color: #eef2ff; /* indigo-50 */
        }
        .draggable-item {
            cursor: grab;
        }
        .draggable-item:active {
            cursor: grabbing;
        }
        .dragging {
            opacity: 0.5;
            background: #e0e7ff; /* indigo-200 */
        }
        /* Interactive page preview styling */
        .page-preview-container {
            position: relative;
            cursor: pointer;
        }
        .page-preview-container.selected-for-removal::after {
            content: '‚ùå';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: white;
            background-color: rgba(239, 68, 68, 0.7);
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Main Container -->
    <div class="container mx-auto px-4 py-8 md:py-12">

        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-indigo-600 mb-2">PDF Tools</h1>
            <p class="text-lg text-slate-500">Fast, private, and secure PDF tools that run entirely in your browser.</p>
            <p class="text-sm text-slate-400 mt-2">Your files never leave your computer.</p>
        </header>

        <!-- Tool Grid -->
        <main id="tool-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 md:gap-6">
            <!-- Tool cards will be dynamically inserted here -->
        </main>

        <!-- Workspace for active tool -->
        <section id="workspace" class="hidden">
            <!-- Workspace content will be dynamically inserted here -->
        </section>

    </div>

    <!-- Global Spinner -->
    <div id="spinner-overlay" class="hidden fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50">
        <div class="flex flex-col items-center">
            <div class="spinner border-4 border-t-4 border-slate-200 border-t-indigo-600 rounded-full w-12 h-12"></div>
            <p id="spinner-message" class="mt-4 text-slate-600"></p>
        </div>
    </div>

    <!-- Global Toast Notification -->
    <div id="toast-notification" class="hidden fixed bottom-5 right-5 p-4 rounded-lg shadow-xl text-white">
        <p id="toast-message"></p>
    </div>

    <script>
        // Immediately-invoked function expression (IIFE) to encapsulate the app logic
        (async () => {
            // Destructure PDFLib functions for easy access
            const { PDFDocument, rgb, StandardFonts, degrees } = PDFLib;

            // DOM Element References
            const toolGrid = document.getElementById('tool-grid');
            const workspace = document.getElementById('workspace');
            const spinner = document.getElementById('spinner-overlay');
            const spinnerMessage = document.getElementById('spinner-message');
            const toast = document.getElementById('toast-notification');
            const toastMessage = document.getElementById('toast-message');

            // --- STATE ---
            let selectedFiles = [];
            let pagesToRemove = new Set();

            // --- AVAILABLE TOOLS ---
            const tools = [
                {
                    id: 'merge',
                    title: 'Merge PDF',
                    icon: 'copy-plus',
                    description: 'Combine multiple PDFs into one single document.',
                    multipleFiles: true,
                    render: renderMergeUI,
                    process: processMerge,
                },
                {
                    id: 'split',
                    title: 'Split PDF',
                    icon: 'scissors',
                    description: 'Extract pages from a PDF by providing page ranges.',
                    multipleFiles: false,
                    render: renderSplitUI,
                    process: processSplit,
                },
                {
                    id: 'remove-pages',
                    title: 'Remove Pages',
                    icon: 'file-minus-2',
                    description: 'Click on pages in the preview to select them for removal.',
                    multipleFiles: false,
                    render: renderRemovePagesUI,
                    process: processRemovePages,
                },
                 {
                    id: 'ocr',
                    title: 'Extract Text (OCR)',
                    icon: 'file-text',
                    description: 'Recognize and extract text from a scanned PDF.',
                    multipleFiles: false,
                    render: renderOcrUI,
                    process: processOcr,
                },
                {
                    id: 'rotate',
                    title: 'Rotate PDF',
                    icon: 'rotate-cw',
                    description: 'Rotate all or specific pages of your PDF.',
                    multipleFiles: false,
                    render: renderRotateUI,
                    process: processRotate,
                },
                {
                    id: 'add-watermark',
                    title: 'Add Watermark',
                    icon: 'stamp',
                    description: 'Add a text watermark to every page of your PDF.',
                    multipleFiles: false,
                    render: renderWatermarkUI,
                    process: processWatermark,
                },
                {
                    id: 'add-numbers',
                    title: 'Page Numbers',
                    icon: 'hash',
                    description: 'Add page numbers to your PDF document.',
                    multipleFiles: false,
                    render: renderPageNumbersUI,
                    process: processPageNumbers,
                },
                {
                    id: 'image-to-pdf',
                    title: 'Image to PDF',
                    icon: 'image',
                    description: 'Convert JPG or PNG images into a PDF file.',
                    multipleFiles: true,
                    render: renderImageToPdfUI,
                    process: processImageToPdf,
                    accept: 'image/jpeg, image/png'
                },
                {
                    id: 'pdf-to-image',
                    title: 'PDF to Image',
                    icon: 'file-image',
                    description: 'Convert each page of a PDF into a JPG image.',
                    multipleFiles: false,
                    render: renderPdfToImageUI,
                    process: processPdfToImage,
                }
            ];

            // --- CORE UI FUNCTIONS ---

            // Renders the main grid of tool cards
            function renderToolGrid() {
                toolGrid.innerHTML = '';
                tools.forEach(tool => {
                    const card = document.createElement('div');
                    card.className = 'tool-card bg-white p-4 rounded-xl shadow-md cursor-pointer flex flex-col items-center text-center';
                    card.innerHTML = `
                        <i data-lucide="${tool.icon}" class="w-10 h-10 text-indigo-500 mb-3"></i>
                        <h3 class="font-semibold text-slate-800">${tool.title}</h3>
                    `;
                    card.addEventListener('click', () => showWorkspace(tool));
                    toolGrid.appendChild(card);
                });
                lucide.createIcons();
            }

            // Shows the workspace for a selected tool
            function showWorkspace(tool) {
                // Reset state
                selectedFiles = [];
                pagesToRemove.clear();

                toolGrid.classList.add('hidden');
                workspace.classList.remove('hidden');
                workspace.innerHTML = `
                    <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
                        <div class="flex items-center justify-between mb-6">
                            <button id="back-button" class="flex items-center gap-2 text-slate-500 hover:text-indigo-600 transition">
                                <i data-lucide="arrow-left" class="w-5 h-5"></i>
                                Back to Tools
                            </button>
                            <h2 class="text-2xl font-bold text-indigo-600 flex items-center gap-3">
                                <i data-lucide="${tool.icon}" class="w-7 h-7"></i>
                                ${tool.title}
                            </h2>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                            <div id="preview-container" class="lg:col-span-3 bg-slate-100 p-2 rounded-lg h-[70vh] overflow-auto border flex items-center justify-center">
                                <p class="text-slate-400 text-center p-4">Select a file to see a preview.</p>
                            </div>
                            <div id="tool-options-container" class="lg:col-span-2 flex flex-col">
                                <p class="text-slate-500 mb-4">${tool.description}</p>
                                <div id="tool-specific-options" class="flex-grow flex flex-col">
                                    <!-- Tool-specific controls will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('back-button').addEventListener('click', hideWorkspace);
                
                const toolOptionsContainer = document.getElementById('tool-options-container');
                const toolSpecificOptions = document.getElementById('tool-specific-options');

                // Render the file input as the primary action
                createFileInput(toolOptionsContainer, tool);
                
                // Render the unique options for the selected tool
                tool.render(toolSpecificOptions, tool);

                // Render the final process button, unless it's a special case like OCR
                if (tool.id !== 'ocr') {
                    createProcessButton(toolOptionsContainer, tool, 'Process');
                }

                lucide.createIcons();
            }

            // Hides the workspace and shows the tool grid
            function hideWorkspace() {
                workspace.innerHTML = '';
                workspace.classList.add('hidden');
                toolGrid.classList.remove('hidden');
            }

            // Generic UI for file input with drag and drop
            function createFileInput(parent, tool) {
                 const fileInputHTML = `
                    <div id="drop-zone" class="mb-4 border-2 border-dashed border-slate-300 rounded-lg p-8 text-center transition-colors">
                        <i data-lucide="upload-cloud" class="w-12 h-12 text-slate-400 mx-auto mb-4"></i>
                        <label for="file-input" class="font-medium text-indigo-600 hover:text-indigo-500 cursor-pointer">
                            Choose file(s)
                            <input type="file" id="file-input" class="sr-only" 
                                ${tool.multipleFiles ? 'multiple' : ''} 
                                accept="${tool.accept || '.pdf'}">
                        </label>
                        <p class="text-slate-500 text-sm mt-1">or drag and drop here</p>
                    </div>
                `;
                parent.insertAdjacentHTML('afterbegin', fileInputHTML);

                const dropZone = document.getElementById('drop-zone');
                const fileInput = document.getElementById('file-input');

                const handleFiles = (files) => {
                    selectedFiles = Array.from(files);
                    if (selectedFiles.length === 0) {
                        clearPreview();
                        return;
                    }
                    updatePreview(tool);
                };

                fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
                
                // Drag and Drop listeners
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drop-zone-active');
                });
                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drop-zone-active');
                });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drop-zone-active');
                    handleFiles(e.dataTransfer.files);
                });
            }

            // Central function to update previews
            function updatePreview(tool) {
                if (tool.id === 'image-to-pdf' || tool.id === 'merge') {
                    renderDraggableFileList(tool);
                } else if (selectedFiles.length > 0 && selectedFiles[0].type === 'application/pdf') {
                    renderPdfPreview(selectedFiles[0], tool.id);
                } else if (selectedFiles.length > 0) {
                     clearPreview(`Invalid file type for this tool. Expected: ${tool.accept || '.pdf'}`);
                } else {
                    clearPreview();
                }
            }


            // Generic UI for the process button
            function createProcessButton(parent, tool, buttonText = 'Process') {
                const buttonHTML = `
                    <div class="mt-auto border-t pt-6 text-right">
                        <button id="process-button" class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-all shadow-sm flex items-center gap-2 ml-auto">
                            <i data-lucide="${tool.id === 'ocr' ? 'scan-text' : 'settings-2'}" class="w-5 h-5"></i>
                            ${buttonText}
                        </button>
                    </div>
                `;
                parent.insertAdjacentHTML('beforeend', buttonHTML);

                document.getElementById('process-button').addEventListener('click', async () => {
                     if (selectedFiles.length === 0) {
                        showToast('Please select one or more files.', 'error');
                        return;
                    }
                    showSpinner(true);
                    try {
                        await tool.process(tool.id);
                    } catch (error) {
                        console.error('An error occurred:', error);
                        showToast(error.message || 'An unexpected error occurred.', 'error');
                    } finally {
                        showSpinner(false);
                    }
                });
                lucide.createIcons();
            }
            
            // --- UI RENDERERS FOR EACH TOOL ---

            function renderMergeUI(parent, tool) {
                // No specific options needed for merge besides the file input.
            }

            function renderSplitUI(parent, tool) {
                parent.innerHTML += `
                    <div class="mt-4">
                        <label for="split-ranges" class="block mb-2 font-medium text-slate-700">Page Ranges</label>
                        <input type="text" id="split-ranges" placeholder="e.g., 1-3, 5, 8-10" class="w-full p-2 border border-slate-300 rounded-md">
                    </div>
                `;
            }

            function renderRemovePagesUI(parent, tool) {
                // No specific options needed, interaction is in the preview.
            }

            function renderRotateUI(parent, tool) {
                parent.innerHTML += `
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                        <div>
                            <label for="rotate-degrees" class="block mb-2 font-medium text-slate-700">Rotation Angle</label>
                            <select id="rotate-degrees" class="w-full p-2 border border-slate-300 rounded-md">
                                <option value="90">90¬∞ Clockwise</option>
                                <option value="180">180¬∞</option>
                                <option value="270">270¬∞ Clockwise (-90¬∞)</option>
                            </select>
                        </div>
                        <div>
                           <label for="rotate-pages" class="block mb-2 font-medium text-slate-700">Pages to Rotate</label>
                           <input type="text" id="rotate-pages" placeholder="e.g., 1-3, 5 (blank for all)" class="w-full p-2 border border-slate-300 rounded-md">
                        </div>
                    </div>
                `;
            }

            function renderWatermarkUI(parent, tool) {
                parent.innerHTML += `
                    <div class="space-y-4 mt-4">
                        <div>
                            <label for="watermark-text" class="block mb-2 font-medium text-slate-700">Watermark Text</label>
                            <input type="text" id="watermark-text" value="CONFIDENTIAL" class="w-full p-2 border border-slate-300 rounded-md">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                               <label for="watermark-size" class="block mb-2 font-medium text-slate-700">Font Size</label>
                               <input type="number" id="watermark-size" value="50" class="w-full p-2 border border-slate-300 rounded-md">
                            </div>
                            <div>
                               <label for="watermark-opacity" class="block mb-2 font-medium text-slate-700">Opacity</label>
                               <input type="range" id="watermark-opacity" min="0" max="1" step="0.1" value="0.5" class="w-full">
                            </div>
                        </div>
                    </div>
                `;
            }
            
            function renderPageNumbersUI(parent, tool) {
                parent.innerHTML += `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                         <div>
                            <label for="page-position" class="block mb-2 font-medium text-slate-700">Position</label>
                            <select id="page-position" class="w-full p-2 border border-slate-300 rounded-md">
                                <option value="bottom-center">Bottom Center</option>
                                <option value="bottom-left">Bottom Left</option>
                                <option value="bottom-right">Bottom Right</option>
                                <option value="top-center">Top Center</option>
                                <option value="top-left">Top Left</option>
                                <option value="top-right">Top Right</option>
                            </select>
                        </div>
                        <div>
                           <label for="font-size" class="block mb-2 font-medium text-slate-700">Font Size</label>
                           <input type="number" id="font-size" value="12" class="w-full p-2 border border-slate-300 rounded-md">
                        </div>
                    </div>
                `;
            }

            function renderImageToPdfUI(parent, tool) {
                // No specific options needed besides file input.
            }
            
            function renderPdfToImageUI(parent, tool) {
                parent.innerHTML += `
                    <div class="mt-4">
                        <label for="image-quality" class="block mb-2 font-medium text-slate-700">Image Quality</label>
                        <input type="range" id="image-quality" min="0.1" max="1" step="0.1" value="0.8" class="w-full">
                        <div class="text-sm text-slate-500 text-center mt-1">Lower quality means smaller file sizes.</div>
                    </div>
                `;
            }

            function renderOcrUI(parent, tool) {
                parent.innerHTML = `
                    <div class="mt-4 bg-slate-50 rounded-lg border h-full flex flex-col">
                        <div class="p-3 border-b flex justify-between items-center">
                            <h3 class="font-semibold text-slate-700">Extracted Text</h3>
                            <div class="flex items-center space-x-2">
                                <button id="copy-btn" class="p-1.5 bg-slate-200 hover:bg-slate-300 text-slate-600 rounded-md transition disabled:opacity-50" title="Copy Text" disabled>
                                    <i data-lucide="copy" class="w-4 h-4"></i>
                                </button>
                                <button id="save-btn" class="p-1.5 bg-slate-200 hover:bg-slate-300 text-slate-600 rounded-md transition disabled:opacity-50" title="Save as .txt" disabled>
                                    <i data-lucide="save" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <pre id="ocr-output" class="whitespace-pre-wrap text-sm text-slate-800 bg-white p-3 flex-grow overflow-y-auto"></pre>
                    </div>
                `;
                createProcessButton(parent.parentElement, tool, 'Extract Text');
                
                document.getElementById('copy-btn').addEventListener('click', () => {
                    const output = document.getElementById('ocr-output');
                    if (output.textContent) {
                         const textArea = document.createElement("textarea");
                         textArea.value = output.textContent;
                         textArea.style.position = "fixed";
                         document.body.appendChild(textArea);
                         textArea.focus();
                         textArea.select();
                         try {
                             document.execCommand('copy');
                             showToast('Text copied to clipboard!', 'success');
                         } catch (err) {
                             showToast('Failed to copy text.', 'error');
                         }
                         document.body.removeChild(textArea);
                    }
                });

                document.getElementById('save-btn').addEventListener('click', () => {
                    const output = document.getElementById('ocr-output');
                    if (output.textContent && selectedFiles.length > 0) {
                        const originalFilename = selectedFiles[0].name.replace(/\.[^/.]+$/, "");
                        download(output.textContent, `${originalFilename}-extracted.txt`, 'text/plain');
                    }
                });
                
                // Add progress bar container for OCR
                parent.innerHTML += `
                    <div class="mt-4">
                         <div id="ocr-progress-container" class="w-full bg-slate-200 rounded-full h-2.5 hidden">
                            <div id="ocr-progress-bar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                         </div>
                         <p id="ocr-status-text" class="text-sm text-slate-500 text-center mt-1"></p>
                    </div>
                `;
            }


            // --- PROCESSING LOGIC FOR EACH TOOL ---

            async function processMerge(toolId) {
                const mergedPdf = await PDFDocument.create();
                for (const file of selectedFiles) {
                    const pdfBytes = await file.arrayBuffer();
                    const pdfDoc = await PDFDocument.load(pdfBytes);
                    const copiedPages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
                    copiedPages.forEach(page => mergedPdf.addPage(page));
                }
                const pdfBytes = await mergedPdf.save();
                download(pdfBytes, 'merged.pdf', 'application/pdf');
                showToast('PDFs merged successfully!', 'success');
            }

            async function processSplit(toolId) {
                const ranges = document.getElementById('split-ranges').value;
                if (!ranges) throw new Error('Please specify page ranges.');
                
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const pageCount = pdfDoc.getPageCount();

                const pageIndices = parsePageRanges(ranges, pageCount);
                if(pageIndices.length === 0) throw new Error('Invalid or empty page ranges provided.');

                const newPdf = await PDFDocument.create();
                const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                copiedPages.forEach(page => newPdf.addPage(page));

                const newPdfBytes = await newPdf.save();
                download(newPdfBytes, `split-${file.name}`, 'application/pdf');
                showToast('PDF split successfully!', 'success');
            }

            async function processRemovePages(toolId) {
                if (pagesToRemove.size === 0) {
                    throw new Error('No pages selected for removal. Click pages in the preview to select them.');
                }
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                
                const allIndices = pdfDoc.getPageIndices();
                const indicesToKeep = allIndices.filter(index => !pagesToRemove.has(index));

                if (indicesToKeep.length === 0) {
                    throw new Error('You cannot remove all pages from the document.');
                }
                
                const newPdf = await PDFDocument.create();
                const copiedPages = await newPdf.copyPages(pdfDoc, indicesToKeep);
                copiedPages.forEach(page => newPdf.addPage(page));

                const newPdfBytes = await newPdf.save();
                download(newPdfBytes, `edited-${file.name}`, 'application/pdf');
                showToast(`${pagesToRemove.size} page(s) removed successfully!`, 'success');
            }
            
            async function processRotate(toolId) {
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                
                const degreesValue = parseInt(document.getElementById('rotate-degrees').value);
                const pageRanges = document.getElementById('rotate-pages').value;
                
                const pageCount = pdfDoc.getPageCount();
                const indicesToRotate = pageRanges ? parsePageRanges(pageRanges, pageCount) : pdfDoc.getPageIndices();

                indicesToRotate.forEach(index => {
                    const page = pdfDoc.getPage(index);
                    // Correctly apply rotation using the `degrees` function from pdf-lib
                    page.rotate(degrees(degreesValue));
                });

                const newPdfBytes = await pdfDoc.save();
                download(newPdfBytes, `rotated-${file.name}`, 'application/pdf');
                showToast('PDF rotated successfully!', 'success');
            }
            
            async function processWatermark(toolId) {
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

                const text = document.getElementById('watermark-text').value;
                const size = parseInt(document.getElementById('watermark-size').value);
                const opacity = parseFloat(document.getElementById('watermark-opacity').value);

                const pages = pdfDoc.getPages();
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const textWidth = font.widthOfTextAtSize(text, size);

                    page.drawText(text, {
                        x: width / 2 - textWidth / 2,
                        y: height / 2,
                        font,
                        size,
                        color: rgb(0, 0, 0),
                        opacity: opacity,
                        rotate: degrees(45),
                    });
                }
                
                const newPdfBytes = await pdfDoc.save();
                download(newPdfBytes, `watermarked-${file.name}`, 'application/pdf');
                showToast('Watermark added successfully!', 'success');
            }
            
            async function processPageNumbers(toolId) {
                const file = selectedFiles[0];
                const pdfBytes = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const pages = pdfDoc.getPages();
                
                const position = document.getElementById('page-position').value;
                const fontSize = parseInt(document.getElementById('font-size').value);
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

                for (let i = 0; i < pages.length; i++) {
                    const page = pages[i];
                    const { width, height } = page.getSize();
                    const pageNum = i + 1;
                    
                    let x, y;
                    const margin = 30;
                    const textWidth = font.widthOfTextAtSize(String(pageNum), fontSize);

                    switch(position) {
                        case 'bottom-left': x = margin; y = margin; break;
                        case 'bottom-right': x = width - margin - textWidth; y = margin; break;
                        case 'top-center': x = width / 2 - textWidth / 2; y = height - margin - fontSize; break;
                        case 'top-left': x = margin; y = height - margin - fontSize; break;
                        case 'top-right': x = width - margin - textWidth; y = height - margin - fontSize; break;
                        default: // bottom-center
                            x = width / 2 - textWidth / 2;
                            y = margin;
                            break;
                    }
                    
                    page.drawText(String(pageNum), { x, y, size: fontSize, font, color: rgb(0, 0, 0) });
                }

                const newPdfBytes = await pdfDoc.save();
                download(newPdfBytes, `numbered-${file.name}`, 'application/pdf');
                showToast('Page numbers added successfully!', 'success');
            }

            async function processImageToPdf(toolId) {
                const pdfDoc = await PDFDocument.create();
                for (const file of selectedFiles) {
                    const imgBytes = await file.arrayBuffer();
                    const image = file.type === 'image/png' 
                        ? await pdfDoc.embedPng(imgBytes) 
                        : await pdfDoc.embedJpg(imgBytes);
                    
                    const page = pdfDoc.addPage();
                    const { width, height } = image.scale(1);
                    page.setSize(width, height);
                    page.drawImage(image, { x: 0, y: 0, width, height });
                }

                const pdfBytes = await pdfDoc.save();
                download(pdfBytes, 'images.pdf', 'application/pdf');
                showToast('Images converted to PDF!', 'success');
            }

            async function processPdfToImage(toolId) {
                const file = selectedFiles[0];
                const quality = parseFloat(document.getElementById('image-quality').value);
                const zip = new JSZip();
                
                const fileReader = new FileReader();
                fileReader.onload = async (event) => {
                    const typedarray = new Uint8Array(event.target.result);
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;
                    const numPages = pdf.numPages;

                    showSpinner(true, `Converting ${numPages} pages...`);

                    for (let i = 1; i <= numPages; i++) {
                        showSpinner(true, `Converting page ${i} of ${numPages}`);
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale: 2.0 });
                        
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport }).promise;
                        
                        const imageDataUrl = canvas.toDataURL('image/jpeg', quality);
                        // We need to convert the data URL to a blob to add to the zip
                        const blob = await (await fetch(imageDataUrl)).blob();
                        zip.file(`page_${i}.jpg`, blob);
                    }
                    
                    showSpinner(true, 'Compressing images into a zip file...');
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const originalFilename = file.name.replace(/\.[^/.]+$/, "");
                    download(zipBlob, `${originalFilename}.zip`, 'application/zip');
                    showToast('PDF converted to images!', 'success');
                    showSpinner(false);
                };
                fileReader.readAsArrayBuffer(file);
            }
            
            async function processOcr(toolId) {
                const file = selectedFiles[0];
                const output = document.getElementById('ocr-output');
                const copyBtn = document.getElementById('copy-btn');
                const saveBtn = document.getElementById('save-btn');
                
                const progressContainer = document.getElementById('ocr-progress-container');
                const progressBar = document.getElementById('ocr-progress-bar');
                const statusText = document.getElementById('ocr-status-text');

                output.textContent = '';
                copyBtn.disabled = true;
                saveBtn.disabled = true;
                progressContainer.classList.add('hidden');
                progressBar.style.width = '0%';
                statusText.textContent = '';

                // Create and manage the Web Worker
                const ocrWorker = new Worker('ocr-worker.js');
                let fullTextByPage = {};
                let pageCount = 0;
                
                ocrWorker.onmessage = (event) => {
                    const { type, payload } = event.data;
                    if (type === 'progress') {
                        if (payload.status === 'recognizing text') {
                            const progress = payload.progress * 100;
                            progressBar.style.width = `${progress}%`;
                        }
                        statusText.textContent = payload.status;
                    } else if (type === 'result') {
                        fullTextByPage[payload.pageIndex] = payload.text;
                        // Reconstruct the full text in order
                        let fullText = '';
                        for(let i = 0; i < pageCount; i++) {
                            if(fullTextByPage[i]) {
                                fullText += fullTextByPage[i] + `\n\n--- Page ${i + 1} ---\n\n`;
                            }
                        }
                        output.textContent = fullText;
                        output.scrollTop = output.scrollHeight;
                    } else if (type === 'ready') {
                         // Worker is initialized, now we can start processing pages.
                        startPdfProcessing();
                    } else if (type === 'terminated') {
                        showSpinner(false);
                        showToast('Text extraction complete!', 'success');
                        statusText.textContent = 'Extraction Complete!';
                        copyBtn.disabled = false;
                        saveBtn.disabled = false;
                    }
                };
                
                // 1. Initialize the worker
                showSpinner(true, 'Initializing OCR engine...');
                ocrWorker.postMessage({ type: 'init' });

                const startPdfProcessing = () => {
                    const fileReader = new FileReader();
                    fileReader.onload = async (e) => {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        pageCount = pdf.numPages;

                        showSpinner(true, `Loading PDF with ${pageCount} pages...`);
                        progressContainer.classList.remove('hidden');

                        for (let i = 1; i <= pageCount; i++) {
                            statusText.textContent = `Rendering page ${i} for OCR...`;
                            const page = await pdf.getPage(i);
                            const viewport = page.getViewport({ scale: 2.0 });

                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            await page.render({ canvasContext: context, viewport }).promise;

                            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                            
                            // 2. Send image data to the worker for recognition
                            ocrWorker.postMessage({ 
                                type: 'recognize', 
                                payload: { imageData: imageData, pageIndex: i-1 }
                            });
                        }
                        // 3. After all pages are sent, tell the worker to terminate
                        ocrWorker.postMessage({ type: 'terminate' });
                    };
                    fileReader.readAsArrayBuffer(file);
                };
            }


            // --- PREVIEW RENDERER FUNCTIONS ---

            function clearPreview(message = 'Select a file to see a preview.') {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = `<p class="text-slate-400 text-center p-4">${message}</p>`;
            }

            async function renderPdfPreview(file, toolId) {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = '<div class="spinner border-4 border-t-4 border-slate-200 border-t-indigo-600 rounded-full w-12 h-12"></div>';
                
                try {
                    const fileReader = new FileReader();
                    fileReader.onload = async function() {
                        const typedarray = new Uint8Array(this.result);
                        const pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                        
                        previewContainer.innerHTML = ''; // Clear spinner
                        
                        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                            const pageIndex = pageNum - 1;
                            const page = await pdfDoc.getPage(pageNum);
                            const viewport = page.getViewport({ scale: 1.5 });
                            
                            const container = document.createElement('div');
                            container.className = 'page-preview-container mb-4 shadow-md';
                            
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            
                            container.appendChild(canvas);
                            previewContainer.appendChild(container);

                            if (toolId === 'remove-pages') {
                                container.addEventListener('click', () => {
                                    if (pagesToRemove.has(pageIndex)) {
                                        pagesToRemove.delete(pageIndex);
                                        container.classList.remove('selected-for-removal');
                                    } else {
                                        pagesToRemove.add(pageIndex);
                                        container.classList.add('selected-for-removal');
                                    }
                                });
                            }
                            
                            const renderContext = {
                                canvasContext: context,
                                viewport: viewport
                            };
                            await page.render(renderContext).promise;
                        }
                    };
                    fileReader.readAsArrayBuffer(file);
                } catch (error) {
                    console.error("Error rendering PDF preview:", error);
                    clearPreview('Could not display a preview for this PDF.');
                }
            }
            
            function renderImagePreview(files) {
                const previewContainer = document.getElementById('preview-container');
                previewContainer.innerHTML = '';
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-2 gap-2 p-2';
                files.forEach(file => {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.className = 'w-full h-auto object-cover rounded-md';
                    img.onload = () => URL.revokeObjectURL(img.src);
                    grid.appendChild(img);
                });
                previewContainer.appendChild(grid);
            }

            function renderDraggableFileList(tool) {
                const previewContainer = document.getElementById('preview-container');
                let listHTML = `<ul id="draggable-list" class="w-full p-4 text-left space-y-2">`;
                selectedFiles.forEach((file, index) => {
                    listHTML += `
                        <li class="draggable-item flex items-center gap-3 bg-white p-2 rounded-md shadow-sm border" draggable="true" data-index="${index}">
                            <i data-lucide="grip-vertical" class="w-5 h-5 text-slate-400"></i>
                            <span class="text-sm text-slate-700 flex-grow">${file.name}</span>
                        </li>
                    `;
                });
                listHTML += `</ul>`;
                previewContainer.innerHTML = listHTML;
                lucide.createIcons();

                const list = document.getElementById('draggable-list');
                let draggedItem = null;

                list.addEventListener('dragstart', e => {
                    draggedItem = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                });

                list.addEventListener('dragend', e => {
                    setTimeout(() => {
                        if (draggedItem) {
                            draggedItem.classList.remove('dragging');
                        }
                        draggedItem = null;
                    }, 0);
                });

                list.addEventListener('dragover', e => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(list, e.clientY);
                    const currentElement = document.querySelector('.dragging');
                    if (afterElement == null) {
                        list.appendChild(currentElement);
                    } else {
                        list.insertBefore(currentElement, afterElement);
                    }
                });
                
                list.addEventListener('drop', e => {
                    e.preventDefault();
                    // Check if draggedItem exists to prevent errors
                    if (!draggedItem) return;
                    
                    const newOrder = [...list.querySelectorAll('.draggable-item')].map(item => {
                         // Find the file from the original selectedFiles array based on the text content
                         // This is more robust than relying on index after reordering
                         const fileName = item.querySelector('span').textContent;
                         return selectedFiles.find(f => f.name === fileName);
                    });
                    selectedFiles = newOrder.filter(f => f); // Filter out any undefined if names mismatch
                    
                    // Re-render to update UI and internal state correctly
                    renderDraggableFileList(tool);
                });

                 function getDragAfterElement(container, y) {
                    const draggableElements = [...container.querySelectorAll('.draggable-item:not(.dragging)')];
                    return draggableElements.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - box.top - box.height / 2;
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;
                }
            }


            function renderMergePreview(files) {
                renderDraggableFileList({id: 'merge'});
            }

            // --- HELPER FUNCTIONS ---

            // Toggles the visibility of the spinner
            function showSpinner(visible, message = '') {
                spinnerMessage.textContent = message;
                spinner.classList.toggle('hidden', !visible);
            }

            // Displays a toast notification
            function showToast(message, type = 'success') {
                toastMessage.textContent = message;
                toast.className = `fixed bottom-5 right-5 p-4 rounded-lg shadow-xl text-white toast ${
                    type === 'success' ? 'bg-green-500' : 'bg-red-500'
                }`;
                toast.classList.remove('hidden');
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 4000);
            }

            // Triggers a file download in the browser
            function download(bytes, filename, mimeType) {
                const blob = new Blob([bytes], { type: mimeType });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }

            // Parses page range strings (e.g., "1-3, 5, 8-10") into an array of zero-based indices
            function parsePageRanges(ranges, pageCount) {
                const indices = new Set();
                const parts = ranges.split(',').map(s => s.trim());
                for (const part of parts) {
                    if (part.includes('-')) {
                        const [start, end] = part.split('-').map(Number);
                        for (let i = start; i <= end; i++) {
                            if (i > 0 && i <= pageCount) indices.add(i - 1);
                        }
                    } else {
                        const pageNum = Number(part);
                        if (pageNum > 0 && pageNum <= pageCount) indices.add(pageNum - 1);
                    }
                }
                return Array.from(indices).sort((a,b) => a - b);
            }


            // --- INITIALIZATION ---
            document.addEventListener('DOMContentLoaded', () => {
                renderToolGrid();
            });

        })();
    </script>
</body>
</html>


